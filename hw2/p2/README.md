# Problem 2, Part 1. 

From the given CFG, it is easy to calculate the number of such straight-line paths. Note that there are two *branches* in the body of the loop. So, in all there will be $2*2 = 4$ *possible* straight-line paths that terminate at the exit point of the loop generated by the unwinding of the CFG for depth $k = 2$. However, out of all these possibilities, only three possible paths will be valid. Note that the path in which the right hand branch is taken in the first iteration, and the left hand branch is taken in the second iteration is not possible (because if the right hand path is taken in the first iteration, it will set `y = x`, and hence the condition `x < y` will fail). The rest of the three possibiities are valid, and hence there are $3$ such straight-line paths.  

1. The first path is $s_0\to s_1\to s_2\to s_5\to s_7\to s_9\to s_{10}\to s_2 \to s_5\to s_7\to s_9\to s_{10}\to s_2\to s_3\to s_4$.

2. The second path is $s_0\to s_1\to s_2\to s_5\to s_6\to s_8\to s_{10}\to s_2 \to s_5\to s_7\to s_9\to s_{10}\to s_2\to s_3\to s_4$.

3. The third path is $s_0\to s_1\to s_2\to s_5\to s_6\to s_8\to s_{10}\to s_2 \to s_5\to s_6\to s_8\to s_{10}\to s_2\to s_3\to s_4$

# Problem 2, Part 2

Now, we will try to encode one such straight-line path in SSA and verify that it proves the property $P$ at the end of the program. Let us encode path number 1 using SSA. Here are all the conjuncts in the SSA encoding.

- $(|x_0 - y_0| \le 2)$. This is equivalent to $(x_0\ge y_0 - 2) \land (x_0\le y_0 + 2)$.
- $(i_0 = 0)$.
- $(i_0\le 10)$. This is the first guard. 
- $!(x_0 < y_0)$. This is the second guard. 
- $(y_1 = x_0)$.
- $(i_1 = i_0 + 1)$.
- $(i_1 \le 10)$. This is the third guard. 
- $!(x_0 < y_1)$. This is the fourth guard. 
- $(y_2 = x_0)$.
- $(i_2 = i_1 + 1)$.
- $!(i_2 \le 10)$. This is the fifth guard, which denotes the loop exit condition.

Let us call the conjunction of all of the above clauses $\phi$. So, $\phi$ represents the SSA formula for this path. Now, the VC for this path will be the following. 
$$\phi\implies (x_0 = y_2)$$
So, to prove the program correct, the SAT solver will try to check whether $\text{UNSAT}(\neg(\phi\implies (x_0 = y_2)))$ is true. We have encoded this formula in `p2.smt2`.

# Problem 2, Part 3

Look at `p1loop.c` for the main code. The file `p2_left.c` contains the code on the left hand side in the problem statement, and the file `p2_right.c` contains the code on the right hand side of problem statement. For the original code, we run CBMC as follows. 

    cbmc p1loop.c --nondet-static --unwind 2 --show-vcc

For the files `p2_left.c` and `p2_right.c`, we run CBMC as follows. 

    cbmc p2_left.c --nondet-static --show-vcc

The VCC for `p1loop.c` is stored in `vcc_original`; that of `p2_left.c` is stored in `vcc_left`, and that of `p2_right.c` is stored in `vcc_right`. Upon comparing `vcc_original` with the other two VCCs, we see that `vcc_right` is closer to `vcc_original` than `vcc_left` is. Morever, the SSA in `vcc_right` is better because of the following reasons. 

1. Only one VCC is generated for the whole code as opposed to multiple VCCs for each assert.
2. Instead of putting multiple lines of code with `assert` statements, we only need to use one `assume` statement and one `assert` statement. 

